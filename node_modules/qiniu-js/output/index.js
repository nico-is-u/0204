(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["qiniu-js"] = {}));
})(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }

    class UploadError {
        constructor(name, message, reqId) {
            this.name = name;
            this.message = message;
            this.reqId = reqId;
            this.stack = new Error().stack;
        }
    }
    class HttpRequestError extends UploadError {
        constructor(httpCode, message, reqId) {
            super('HttpRequestError', message);
            this.httpCode = httpCode;
            this.reqId = reqId;
        }
    }

    /* eslint-disable */
    // https://github.com/locutusjs/locutus/blob/master/src/php/xml/utf8_encode.js
    function utf8Encode(argString) {
        // http://kevin.vanzonneveld.net
        // +   original by: Webtoolkit.info (http://www.webtoolkit.info/)
        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // +   improved by: sowberry
        // +    tweaked by: Jack
        // +   bugfixed by: Onno Marsman
        // +   improved by: Yves Sucaet
        // +   bugfixed by: Onno Marsman
        // +   bugfixed by: Ulrich
        // +   bugfixed by: Rafal Kukawski
        // +   improved by: kirilloid
        // +   bugfixed by: kirilloid
        // *     example 1: this.utf8Encode('Kevin van Zonneveld')
        // *     returns 1: 'Kevin van Zonneveld'
        if (argString === null || typeof argString === 'undefined') {
            return '';
        }
        let string = argString + ''; // .replace(/\r\n/g, '\n').replace(/\r/g, '\n')
        let utftext = '', start, end, stringl = 0;
        start = end = 0;
        stringl = string.length;
        for (let n = 0; n < stringl; n++) {
            let c1 = string.charCodeAt(n);
            let enc = null;
            if (c1 < 128) {
                end++;
            }
            else if (c1 > 127 && c1 < 2048) {
                enc = String.fromCharCode((c1 >> 6) | 192, (c1 & 63) | 128);
            }
            else if ((c1 & 0xf800 ^ 0xd800) > 0) {
                enc = String.fromCharCode((c1 >> 12) | 224, ((c1 >> 6) & 63) | 128, (c1 & 63) | 128);
            }
            else {
                // surrogate pairs
                if ((c1 & 0xfc00 ^ 0xd800) > 0) {
                    throw new RangeError('Unmatched trail surrogate at ' + n);
                }
                let c2 = string.charCodeAt(++n);
                if ((c2 & 0xfc00 ^ 0xdc00) > 0) {
                    throw new RangeError('Unmatched lead surrogate at ' + (n - 1));
                }
                c1 = ((c1 & 0x3ff) << 10) + (c2 & 0x3ff) + 0x10000;
                enc = String.fromCharCode((c1 >> 18) | 240, ((c1 >> 12) & 63) | 128, ((c1 >> 6) & 63) | 128, (c1 & 63) | 128);
            }
            if (enc !== null) {
                if (end > start) {
                    utftext += string.slice(start, end);
                }
                utftext += enc;
                start = end = n + 1;
            }
        }
        if (end > start) {
            utftext += string.slice(start, stringl);
        }
        return utftext;
    }
    // https://github.com/locutusjs/locutus/blob/master/src/php/xml/utf8_decode.js
    function utf8Decode(strData) {
        // eslint-disable-line camelcase
        //  discuss at: https://locutus.io/php/utf8_decode/
        // original by: Webtoolkit.info (https://www.webtoolkit.info/)
        //    input by: Aman Gupta
        //    input by: Brett Zamir (https://brett-zamir.me)
        // improved by: Kevin van Zonneveld (https://kvz.io)
        // improved by: Norman "zEh" Fuchs
        // bugfixed by: hitwork
        // bugfixed by: Onno Marsman (https://twitter.com/onnomarsman)
        // bugfixed by: Kevin van Zonneveld (https://kvz.io)
        // bugfixed by: kirilloid
        // bugfixed by: w35l3y (https://www.wesley.eti.br)
        //   example 1: utf8_decode('Kevin van Zonneveld')
        //   returns 1: 'Kevin van Zonneveld'
        const tmpArr = [];
        let i = 0;
        let c1 = 0;
        let seqlen = 0;
        strData += '';
        while (i < strData.length) {
            c1 = strData.charCodeAt(i) & 0xFF;
            seqlen = 0;
            // https://en.wikipedia.org/wiki/UTF-8#Codepage_layout
            if (c1 <= 0xBF) {
                c1 = (c1 & 0x7F);
                seqlen = 1;
            }
            else if (c1 <= 0xDF) {
                c1 = (c1 & 0x1F);
                seqlen = 2;
            }
            else if (c1 <= 0xEF) {
                c1 = (c1 & 0x0F);
                seqlen = 3;
            }
            else {
                c1 = (c1 & 0x07);
                seqlen = 4;
            }
            for (let ai = 1; ai < seqlen; ++ai) {
                c1 = ((c1 << 0x06) | (strData.charCodeAt(ai + i) & 0x3F));
            }
            if (seqlen === 4) {
                c1 -= 0x10000;
                tmpArr.push(String.fromCharCode(0xD800 | ((c1 >> 10) & 0x3FF)));
                tmpArr.push(String.fromCharCode(0xDC00 | (c1 & 0x3FF)));
            }
            else {
                tmpArr.push(String.fromCharCode(c1));
            }
            i += seqlen;
        }
        return tmpArr.join('');
    }
    function base64Encode(data) {
        // http://kevin.vanzonneveld.net
        // +   original by: Tyler Akins (http://rumkin.com)
        // +   improved by: Bayron Guevara
        // +   improved by: Thunder.m
        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // +   bugfixed by: Pellentesque Malesuada
        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // -    depends on: this.utf8Encode
        // *     example 1: this.base64Encode('Kevin van Zonneveld')
        // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='
        // mozilla has this native
        // - but breaks in 2.0.0.12!
        // if (typeof this.window['atob'] == 'function') {
        //    return atob(data)
        // }
        let b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        let o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc = '', tmp_arr = [];
        if (!data) {
            return data;
        }
        data = utf8Encode(data + '');
        do {
            // pack three octets into four hexets
            o1 = data.charCodeAt(i++);
            o2 = data.charCodeAt(i++);
            o3 = data.charCodeAt(i++);
            bits = (o1 << 16) | (o2 << 8) | o3;
            h1 = (bits >> 18) & 0x3f;
            h2 = (bits >> 12) & 0x3f;
            h3 = (bits >> 6) & 0x3f;
            h4 = bits & 0x3f;
            // use hexets to index into b64, and append result to encoded string
            tmp_arr[ac++] =
                b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
        } while (i < data.length);
        enc = tmp_arr.join('');
        switch (data.length % 3) {
            case 1:
                enc = enc.slice(0, -2) + '==';
                break;
            case 2:
                enc = enc.slice(0, -1) + '=';
                break;
        }
        return enc;
    }
    function base64Decode(data) {
        // http://kevin.vanzonneveld.net
        // +   original by: Tyler Akins (http://rumkin.com)
        // +   improved by: Thunder.m
        // +      input by: Aman Gupta
        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // +   bugfixed by: Onno Marsman
        // +   bugfixed by: Pellentesque Malesuada
        // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // +      input by: Brett Zamir (http://brett-zamir.me)
        // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
        // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==')
        // *     returns 1: 'Kevin van Zonneveld'
        // mozilla has this native
        // - but breaks in 2.0.0.12!
        // if (typeof this.window['atob'] == 'function') {
        //    return atob(data)
        // }
        let b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        let o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, dec = '', tmp_arr = [];
        if (!data) {
            return data;
        }
        data += '';
        do { // unpack four hexets into three octets using index points in b64
            h1 = b64.indexOf(data.charAt(i++));
            h2 = b64.indexOf(data.charAt(i++));
            h3 = b64.indexOf(data.charAt(i++));
            h4 = b64.indexOf(data.charAt(i++));
            bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;
            o1 = bits >> 16 & 0xff;
            o2 = bits >> 8 & 0xff;
            o3 = bits & 0xff;
            if (h3 === 64) {
                tmp_arr[ac++] = String.fromCharCode(o1);
            }
            else if (h4 === 64) {
                tmp_arr[ac++] = String.fromCharCode(o1, o2);
            }
            else {
                tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
            }
        } while (i < data.length);
        dec = tmp_arr.join('');
        return utf8Decode(dec);
    }
    function urlSafeBase64Encode(v) {
        v = base64Encode(v);
        // 参考 https://tools.ietf.org/html/rfc4648#section-5
        return v.replace(/\//g, '_').replace(/\+/g, '-');
    }
    function urlSafeBase64Decode(v) {
        v = v.replace(/_/g, '/').replace(/-/g, '+');
        return base64Decode(v);
    }

    function removeUndefinedKeys(obj) {
        const newOby = {};
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                if (obj[key] !== undefined) {
                    newOby[key] = obj[key];
                }
            }
        }
        return newOby;
    }

    function isErrorResult(result) {
        return !!(result && 'error' in result);
    }
    function isCanceledResult(result) {
        return !!(result && 'canceled' in result && result.canceled);
    }
    function isSuccessResult(result) {
        return !!(!isErrorResult(result) && !isCanceledResult(result) && result && 'result' in result);
    }

    class HttpAbortController {
        constructor() {
            this.aborted = false;
            this.listeners = new Array();
        }
        abort() {
            if (this.aborted) {
                return;
            }
            this.aborted = true;
            for (const listener of this.listeners) {
                listener();
            }
        }
        onAbort(callback) {
            if (!this.listeners.includes(callback)) {
                this.listeners.push(callback);
            }
        }
    }
    class HttpFormData {
        constructor() {
            this.value = new Map();
        }
        set(key, value, option) {
            this.value.set(key, { value, option });
        }
        get(key) {
            return this.value.get(key);
        }
        forEach(callback) {
            this.value.forEach((value, key) => callback(key, value.value, value.option));
        }
        entries() {
            const result = [];
            this.forEach((key, value, option) => result.push([key, value, option]));
            return result;
        }
    }
    function isHttpFormData(data) {
        return data && data instanceof HttpFormData;
    }

    function parseResponseJson(response) {
        return __awaiter(this, void 0, void 0, function* () {
            let parsedData;
            try {
                parsedData = JSON.parse(response.data || '');
            }
            catch (error) {
                const message = `Bad response data, cannot be parsed: ${response.data}`;
                return { error: new HttpRequestError(response.code, message) };
            }
            return { result: parsedData };
        });
    }
    function handleResponseError(response) {
        return __awaiter(this, void 0, void 0, function* () {
            if (response.code === 404) {
                const message = 'Invalid apiServerUrl: the URL is wrong or the storage cluster version is not supported.';
                return { error: new HttpRequestError(response.code, message, '') };
            }
            let responseData;
            try {
                responseData = JSON.parse(response.data || '');
            }
            catch (error) {
                const message = `Bad response data, cannot be parsed: ${response.data}`;
                return { error: new HttpRequestError(response.code, message, response.reqId) };
            }
            if (responseData !== null && typeof responseData === 'object' && 'error' in responseData) {
                return { error: new HttpRequestError(response.code, responseData.error, response.reqId) };
            }
            const message = `Unknown response error: ${response.data}`;
            return { error: new HttpRequestError(response.code, message, response.reqId) };
        });
    }
    class UploadApis {
        constructor(
        /** http 请求客户端；通过实现不同的 HttpClient 来实现多环境支持 */
        httpClient) {
            this.httpClient = httpClient;
        }
        generateAuthHeaders(token) {
            const auth = 'UpToken ' + token;
            return { Authorization: auth };
        }
        getBaseRequestPath(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const realKey = params.key != null ? urlSafeBase64Encode(params.key) : '~';
                const url = `${params.uploadHostUrl}/buckets/${params.token.bucket}/objects/${realKey}/uploads`;
                return { result: url };
            });
        }
        initMultipartUpload(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const requestPathResult = yield this.getBaseRequestPath(params);
                if (!isSuccessResult(requestPathResult))
                    return requestPathResult;
                const headers = this.generateAuthHeaders(params.token.signature);
                headers['content-type'] = 'application/json';
                const response = yield this.httpClient.post(requestPathResult.result, {
                    headers,
                    abort: params.abort,
                    onProgress: params.onProgress
                });
                if (!isSuccessResult(response)) {
                    return response;
                }
                if (response.result.code !== 200) {
                    return handleResponseError(response.result);
                }
                return parseResponseJson(response.result);
            });
        }
        // v2 接口
        uploadPart(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const requestPathResult = yield this.getBaseRequestPath(params);
                if (!isSuccessResult(requestPathResult))
                    return requestPathResult;
                const url = `${requestPathResult.result}/${params.uploadId}/${params.partIndex}`;
                const headers = this.generateAuthHeaders(params.token.signature);
                headers['content-type'] = 'application/octet-stream'; // 固定为此值
                if (params.md5)
                    headers['Content-MD5'] = params.md5;
                const response = yield this.httpClient.put(url, {
                    onProgress: params.onProgress,
                    abort: params.abort,
                    body: params.part,
                    headers
                });
                if (!isSuccessResult(response)) {
                    return response;
                }
                if (response.result.code !== 200) {
                    return handleResponseError(response.result);
                }
                return parseResponseJson(response.result);
            });
        }
        listParts(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const requestPathResult = yield this.getBaseRequestPath(params);
                if (!isSuccessResult(requestPathResult))
                    return requestPathResult;
                const url = `${requestPathResult.result}/${params.uploadId}`;
                const headers = this.generateAuthHeaders(params.token.signature);
                headers['content-type'] = 'application/json';
                const response = yield this.httpClient.get(url, {
                    headers,
                    abort: params.abort,
                    onProgress: params.onProgress
                });
                if (!isSuccessResult(response)) {
                    return response;
                }
                if (response.result.code !== 200) {
                    return handleResponseError(response.result);
                }
                return parseResponseJson(response.result);
            });
        }
        completeMultipartUpload(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const requestPathResult = yield this.getBaseRequestPath(params);
                if (!isSuccessResult(requestPathResult))
                    return requestPathResult;
                const url = `${requestPathResult.result}/${params.uploadId}`;
                const headers = this.generateAuthHeaders(params.token.signature);
                headers['content-type'] = 'application/json'; // 固定为改值
                const body = {
                    parts: params.parts,
                    fname: params.fileName,
                    mimeType: params.mimeType
                };
                if (params.customVars) {
                    body.customVars = {};
                    for (const [key, value] of Object.entries(params.customVars)) {
                        body.customVars[`x:${key}`] = value;
                    }
                }
                if (params.metadata) {
                    body.metadata = {};
                    for (const [key, value] of Object.entries(params.metadata)) {
                        body.metadata[`x-qn-meta-${key}`] = value;
                    }
                }
                const response = yield this.httpClient.post(url, {
                    headers,
                    abort: params.abort,
                    onProgress: params.onProgress,
                    body: removeUndefinedKeys(body)
                });
                if (!isSuccessResult(response)) {
                    return response;
                }
                if (response.result.code !== 200) {
                    return handleResponseError(response.result);
                }
                return { result: response.result.data };
            });
        }
        abortMultipartUpload(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const requestPathResult = yield this.getBaseRequestPath(params);
                if (!isSuccessResult(requestPathResult))
                    return requestPathResult;
                const url = `${requestPathResult.result}/${params.uploadId}`;
                const headers = this.generateAuthHeaders(params.token.signature);
                headers['content-type'] = 'application/json';
                const response = yield this.httpClient.delete(url, {
                    headers,
                    abort: params.abort,
                    onProgress: params.onProgress
                });
                if (!isSuccessResult(response)) {
                    return response;
                }
                if (response.result.code !== 200) {
                    return handleResponseError(response.result);
                }
                return { result: response.result.data };
            });
        }
        // v1 接口
        mkblk(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const blobSize = params.firstChunkBinary.size();
                const url = `${params.uploadHostUrl}/mkblk/${blobSize}`;
                const headers = this.generateAuthHeaders(params.token.signature);
                headers['content-type'] = 'application/octet-stream';
                const response = yield this.httpClient.post(url, {
                    headers,
                    abort: params.abort,
                    body: params.firstChunkBinary,
                    onProgress: params.onProgress
                });
                if (!isSuccessResult(response)) {
                    return response;
                }
                if (response.result.code !== 200) {
                    return handleResponseError(response.result);
                }
                return parseResponseJson(response.result);
            });
        }
        mkfile(params) {
            return __awaiter(this, void 0, void 0, function* () {
                let url = `${params.uploadHostUrl}/mkfile/${params.fileSize}`;
                if (params.key) {
                    url += `/key/${urlSafeBase64Encode(params.key)}`;
                }
                if (params.fname) {
                    url += `/fname/${urlSafeBase64Encode(params.fname)}`;
                }
                if (params.mimeType) {
                    url += `/mimeType/${urlSafeBase64Encode(params.mimeType)}`;
                }
                if (params.userVars && Array.isArray(params.userVars)) {
                    for (const [key, value] of Object.entries(params.userVars)) {
                        url += `/x:${key}/${value}`;
                    }
                }
                const headers = this.generateAuthHeaders(params.token.signature);
                headers['content-type'] = 'text/plain';
                const response = yield this.httpClient.post(url, {
                    headers,
                    abort: params.abort,
                    onProgress: params.onProgress,
                    body: params.lastCtxOfBlock.join(',')
                });
                if (!isSuccessResult(response)) {
                    return response;
                }
                if (response.result.code !== 200) {
                    return handleResponseError(response.result);
                }
                return { result: response.result.data };
            });
        }
        //  直传接口
        directUpload(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const formData = new HttpFormData();
                formData.set('token', params.token.signature);
                if (params.key !== undefined)
                    formData.set('key', params.key);
                if (params.crc32 !== undefined)
                    formData.set('crc32', params.crc32);
                if (params.file !== undefined)
                    formData.set('file', params.file, params.fileName);
                if (params.customVars) {
                    for (const [key, value] of Object.entries(params.customVars)) {
                        formData.set(`x:${key}`, value);
                    }
                }
                if (params.metadata) {
                    for (const [key, value] of Object.entries(params.metadata)) {
                        formData.set(`x-qn-meta-${key}`, value);
                    }
                }
                const headers = { 'content-type': 'multipart/form-data' };
                const response = yield this.httpClient.post(params.uploadHostUrl, {
                    headers,
                    body: formData,
                    abort: params.abort,
                    onProgress: params.onProgress
                });
                if (!isSuccessResult(response)) {
                    return response;
                }
                if (response.result.code !== 200) {
                    return handleResponseError(response.result);
                }
                return { result: response.result.data };
            });
        }
    }
    class ConfigApis {
        constructor(
        /** 配置中心的服务地址 */
        serverUrl, 
        /** http 请求客户端；通过实现不同的 HttpClient 来实现多环境支持 */
        httpClient) {
            this.serverUrl = serverUrl;
            this.httpClient = httpClient;
        }
        /** 从服务中心获取接口服务地址 */
        getHostConfig(params) {
            return __awaiter(this, void 0, void 0, function* () {
                /** 从配置中心获取上传服务地址 */
                const query = `ak=${encodeURIComponent(params.assessKey)}&bucket=${encodeURIComponent(params.bucket)}`;
                // TODO: 支持设置，私有云自动获取上传地址
                const url = `${this.serverUrl}/v4/query?${query}`;
                const response = yield this.httpClient.get(url);
                if (!isSuccessResult(response)) {
                    return response;
                }
                if (response.result.code !== 200) {
                    return handleResponseError(response.result);
                }
                return parseResponseJson(response.result);
            });
        }
    }

    function generateRandomString(length = 18) {
        let result = '';
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        const charactersLength = characters.length;
        for (let i = 0; i < length; i++) {
            result += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
        return result;
    }

    const LogLevelWidth = {
        NONE: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3
    };
    class Logger {
        constructor(logLevel = 'NONE', prefix = 'DEFAULT') {
            this.logLevel = logLevel;
            this.prefix = prefix;
        }
        log(level, message) {
            if (this.logLevel === 'NONE')
                return;
            if (LogLevelWidth[level] >= LogLevelWidth[this.logLevel]) {
                // eslint-disable-next-line no-console
                console.log(`[${this.prefix}][${level}]: ${message}`);
            }
        }
        info(message) {
            this.log('INFO', message);
        }
        warn(message) {
            this.log('WARN', message);
        }
        error(message) {
            this.log('ERROR', message);
        }
    }

    const delay = (ms = 1000) => new Promise(resolve => setTimeout(resolve, ms));
    class TaskQueue {
        constructor(options) {
            var _a, _b;
            this.options = options;
            /** 取消标记 */
            this.canceled = false;
            /** 队列正在处理中 */
            this.processing = false;
            /** 队列并发标记 */
            this.concurrentTicket = 1;
            /** 用户传入的任务 */
            this.tasks = [];
            /** 通过 tasksCreator 动态创建的任务 */
            this.dynamicTasks = [];
            /** 任务的状态表 */
            this.taskStates = new Map();
            /** 状态订阅函数表 */
            this.errorListeners = new Map();
            this.cancelListeners = new Map();
            this.progressListeners = new Map();
            this.completeListeners = new Map();
            this.tasksCreator = options === null || options === void 0 ? void 0 : options.tasksCreator;
            this.concurrentTicket = (options === null || options === void 0 ? void 0 : options.concurrentLimit) || 1;
            this.logger = new Logger((_a = options === null || options === void 0 ? void 0 : options.logger) === null || _a === void 0 ? void 0 : _a.level, (_b = options === null || options === void 0 ? void 0 : options.logger) === null || _b === void 0 ? void 0 : _b.prefix);
        }
        handleProgress() {
            const progressListenerList = [...this.progressListeners.values()];
            for (let index = 0; index < progressListenerList.length; index++) {
                const progressListener = progressListenerList[index];
                if (progressListener)
                    progressListener();
            }
        }
        handleComplete() {
            const completeListenerList = [...this.completeListeners.values()];
            for (let index = 0; index < completeListenerList.length; index++) {
                const completeListener = completeListenerList[index];
                if (completeListener)
                    completeListener();
            }
            this.processing = false;
        }
        handleError() {
            const errorListenerList = [...this.errorListeners.values()];
            for (let index = 0; index < errorListenerList.length; index++) {
                const errorListener = errorListenerList[index];
                if (errorListener)
                    errorListener();
            }
            this.processing = false;
        }
        handleCancel() {
            const cancelListenerList = [...this.cancelListeners.values()];
            for (let index = 0; index < cancelListenerList.length; index++) {
                const cancelListener = cancelListenerList[index];
                if (cancelListener)
                    cancelListener();
            }
            this.processing = false;
        }
        onProgress(listener) {
            const uuid = generateRandomString();
            this.progressListeners.set(uuid, listener);
            return () => this.progressListeners.delete(uuid);
        }
        onComplete(listener) {
            const uuid = generateRandomString();
            this.completeListeners.set(uuid, listener);
            return () => this.completeListeners.delete(uuid);
        }
        onError(listener) {
            const uuid = generateRandomString();
            this.errorListeners.set(uuid, listener);
            return () => this.errorListeners.delete(uuid);
        }
        onCancel(listener) {
            const uuid = generateRandomString();
            this.cancelListeners.set(uuid, listener);
            return () => this.cancelListeners.delete(uuid);
        }
        getTaskState(task) {
            const state = this.taskStates.get(task);
            if (state == null) {
                const initState = { status: 'waiting', retryCount: 0 };
                this.taskStates.set(task, initState);
            }
            return this.taskStates.get(task);
        }
        /** 任务处理函数；递归取出任务并执行，除非遇到 canceled 或 error 状态 */
        process(paddingTask) {
            return __awaiter(this, void 0, void 0, function* () {
                // 任务已经取消了
                if (this.canceled) {
                    this.logger.info('Process exited because canceled');
                    return;
                }
                // 常规任务处理逻辑
                if (paddingTask != null) {
                    this.logger.info('In process with padding task');
                    if (this.concurrentTicket === 0) {
                        this.logger.info('Process exited because concurrentTicket is 0');
                        return;
                    }
                    // 读取任务的当前状态
                    const state = this.getTaskState(paddingTask);
                    this.concurrentTicket -= 1;
                    state.status = 'processing';
                    const isQueue = paddingTask instanceof TaskQueue;
                    let queueCleanListeners; // 清理临时监听
                    const progressChange = () => this.handleProgress(); // 绑定 this
                    if (isQueue)
                        queueCleanListeners = paddingTask.onProgress(progressChange);
                    this.logger.info(`Padding task is a ${isQueue ? 'Queue' : 'Task'}`);
                    const result = yield (isQueue ? paddingTask.start() : paddingTask.process(progressChange));
                    this.logger.info(`Task is resolved ${JSON.stringify(result)}`);
                    this.concurrentTicket += 1;
                    queueCleanListeners === null || queueCleanListeners === void 0 ? void 0 : queueCleanListeners();
                    // 该任务已经取消，更新状态啥也不干
                    if (isCanceledResult(result)) {
                        state.status = 'canceled';
                        this.handleCancel();
                        return;
                    }
                    // 成功，继续进行下次递归
                    if (isSuccessResult(result)) {
                        // 成功则继续向后处理
                        state.status = 'success';
                        this.handleProgress();
                        this.process();
                        return;
                    }
                    // 发生错误，重试或停止任务队列
                    if (isErrorResult(result)) {
                        state.status = 'error';
                        this.error = result.error;
                        // 网络错误，等待一定时间后重试
                        if (result.error.name === 'NetworkError') {
                            // 原本 1 次 + 重试 2 次 = 总计 3 次
                            if (state.retryCount < 2) {
                                state.retryCount++;
                                yield delay(2000);
                                // 继续处理这个任务
                                this.process(paddingTask);
                                return;
                            }
                        }
                        this.handleError();
                        this.cancel(); // 停止队列
                    }
                    this.logger.error('Unknown task execution status');
                    return;
                }
                // 获取处于 waiting 中的任务
                const allTasks = [...this.tasks, ...this.dynamicTasks];
                const waitingTasks = allTasks.filter(task => {
                    const state = this.getTaskState(task);
                    return state.status === 'waiting';
                });
                this.logger.info(`There are now ${waitingTasks.length} tasks in waiting`);
                this.logger.info(`There are now ${this.concurrentTicket} concurrency limit`);
                // 根据 concurrentLimit 取出任务并执行
                if (waitingTasks.length > 0 && this.concurrentTicket > 0) {
                    // 如果还有任务则根据当前剩余的 concurrentTicket 取出任务并执行
                    const pendingTasks = waitingTasks.slice(0, this.concurrentTicket);
                    this.logger.info(`${pendingTasks.length} tasks were called up`);
                    for (let index = 0; index < pendingTasks.length; index++) {
                        this.process(pendingTasks[index]);
                    }
                    return;
                }
                // 获取所有已经完成的任务
                const completedTasks = allTasks.filter(task => {
                    const state = this.getTaskState(task);
                    return state.status === 'success';
                });
                // 如果任务全部完成了，则触发 complete 事件
                if (completedTasks.length === allTasks.length) {
                    this.handleComplete();
                }
            });
        }
        /** 添加任务 */
        enqueue(...tasks) {
            if (this.processing)
                throw new Error('task is processing');
            // 清空现有任务并设置新的任务
            this.tasks.splice(0, Infinity);
            this.tasks.push(...tasks);
        }
        /** 开始处理 */
        start() {
            return __awaiter(this, void 0, void 0, function* () {
                this.logger.info('--------------------------');
                this.logger.info('Start processing the queue');
                return new Promise(resolve => {
                    var _a;
                    if (this.processing) {
                        this.logger.error('Queue exited because its processing');
                        return resolve({ error: new UploadError('InternalError', 'Task is processing') });
                    }
                    // 初始化全局状态
                    this.canceled = false;
                    this.processing = true;
                    this.error = undefined;
                    this.taskStates.clear();
                    this.concurrentTicket = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.concurrentLimit) || 1;
                    this.logger.info('Initialize queue status');
                    // 任务状态和 start 函数返回绑定
                    this.onComplete(() => {
                        resolve({ result: true });
                        this.logger.info('Queue is complete');
                    });
                    this.onCancel(() => {
                        resolve({ canceled: true });
                        this.logger.info('Queue is canceled');
                    });
                    this.onError(() => {
                        var _a;
                        resolve({ error: this.error });
                        this.logger.error(`Queue has error: ${(_a = this.error) === null || _a === void 0 ? void 0 : _a.message}`);
                    });
                    // 如果队列有任务创建方法则执行创建
                    if (this.tasksCreator) {
                        // 清空当前的 dynamicTasks
                        this.logger.info('Call tasksCreator');
                        this.dynamicTasks.splice(0, Infinity);
                        this.tasksCreator().then(result => {
                            if (isSuccessResult(result)) {
                                this.logger.info('TasksCreator execution successful');
                                this.dynamicTasks.push(...result.result);
                                // 任务创建完成，开始处理
                                this.process();
                            }
                            // 发生错误
                            if (isErrorResult(result)) {
                                this.logger.info(`TasksCreator execution has error: ${result.error.message}`);
                                this.error = result.error;
                                this.handleError();
                            }
                            this.logger.info('TasksCreator execution completed');
                        });
                        return;
                    }
                    // 开始处理任务
                    this.process();
                });
            });
        }
        /** 取消任务 */
        cancel() {
            return __awaiter(this, void 0, void 0, function* () {
                this.logger.info('Cancel the queue');
                const cancelPromises = [];
                for (const task of [...this.tasks, ...this.dynamicTasks]) {
                    const state = this.getTaskState(task);
                    // 处理中的任务需要进行取消操作
                    const shouldCanceled = ['processing'];
                    if (shouldCanceled.includes(state.status)) {
                        cancelPromises.push(task.cancel());
                    }
                }
                this.logger.info(`Cancel ${cancelPromises.length} tasks in the queue`);
                const result = yield Promise.all(cancelPromises);
                this.processing = false;
                for (const cancelItem of result) {
                    if (!isSuccessResult(cancelItem)) {
                        return cancelItem;
                    }
                }
                this.logger.info('Cancel completed');
                this.canceled = true;
                return { result: true };
            });
        }
    }

    /** 根据 details 上的信息更新总的信息 */
    function updateTotalIntoProgress(progress) {
        const detailValues = Object.values(progress.details);
        let totalSize = 0;
        let totalPercent = 0;
        for (let index = 0; index < detailValues.length; index++) {
            const value = detailValues[index];
            totalSize += value.size;
            totalPercent += value.percent;
        }
        const newPercent = totalPercent / detailValues.length;
        progress.percent = newPercent;
        progress.size = totalSize;
        return progress;
    }
    /** 上传任务的队列上下文 */
    class UploadContext {
        constructor() {
            this.progress = {
                size: 0,
                percent: 0,
                details: {}
            };
        }
        setup() {
            this.error = undefined;
            if (this.progress) {
                // 重置所有的进度为 0
                this.progress.size = 0;
                this.progress.percent = 0;
                for (const key in this.progress.details) {
                    if (Object.prototype.hasOwnProperty.call(this.progress.details, key)) {
                        this.progress.details[key] = {
                            size: 0,
                            percent: 0,
                            fromCache: false
                        };
                    }
                }
            }
        }
    }

    function initUploadConfig(config) {
        if (!config.httpClient)
            throw new Error('HttpClient parameter must be set');
        if (!config.tokenProvider)
            throw new Error('TokenProvider parameter must be set');
        const logLevel = config.logLevel || 'NONE';
        const protocol = config.protocol || 'HTTPS';
        const uploadHosts = config.uploadHosts || [];
        const apiServerUrl = config.apiServerUrl || 'https://api.qiniu.com';
        return Object.assign(Object.assign({}, config), { protocol, apiServerUrl, logLevel, uploadHosts });
    }

    /** 虚拟进度条；在没有调用 end 之前会无限慢慢逼近 100%，但不会到达 100% */
    class MockProgress {
        constructor(
        /** 最大时间；单位为秒 */
        timeConstant = 1) {
            this.timeConstant = timeConstant;
            this.progress = 0;
            this.intervalIds = [];
            this.listeners = [];
        }
        clearInterval() {
            for (const intervalId of this.intervalIds) {
                clearInterval(intervalId);
            }
            this.intervalIds = [];
        }
        callListeners() {
            for (const listener of this.listeners) {
                listener(this.progress);
            }
        }
        setProgress(progress) {
            this.progress = progress;
            this.callListeners();
        }
        start() {
            this.clearInterval();
            let time = 0;
            this.progress = 0;
            const intervalFrequency = 400;
            const intervalIds = setInterval(() => {
                time += intervalFrequency;
                this.setProgress(1 - Math.exp(-1 * time / (this.timeConstant * 1000)));
            }, intervalFrequency);
            this.intervalIds.push(intervalIds);
        }
        end() {
            this.clearInterval();
            this.setProgress(1);
        }
        stop() {
            this.clearInterval();
        }
        onProgress(listener) {
            this.listeners.push(listener);
        }
    }

    /**
      * @description 解冻时间，key 是 host，value 为解冻时间
      */
    const unfreezeTimeMap = new Map();
    class Host {
        constructor(host, protocol) {
            this.host = host;
            this.protocol = protocol;
        }
        /**
         * @description 当前 host 是否为冻结状态
         */
        isFrozen() {
            const currentTime = new Date().getTime();
            const unfreezeTime = unfreezeTimeMap.get(this.host);
            return unfreezeTime != null && unfreezeTime >= currentTime;
        }
        /**
         * @param  {number} time 单位秒，默认 20s
         * @description 冻结该 host 对象，该 host 将在指定时间内不可用
         */
        freeze(time = 20) {
            const unfreezeTime = new Date().getTime() + (time * 1000);
            unfreezeTimeMap.set(this.host, unfreezeTime);
        }
        /**
         * @description 解冻该 host
         */
        unfreeze() {
            unfreezeTimeMap.delete(this.host);
        }
        /**
         * @description 获取当前 host 的完整 url
         */
        getUrl() {
            return `${this.protocol.toLowerCase()}://${this.host}`;
        }
        /**
         * @description 获取解冻时间
         */
        getUnfreezeTime() {
            return unfreezeTimeMap.get(this.host);
        }
    }
    class HostProvider {
        constructor(protocol, configApis, initHosts) {
            this.protocol = protocol;
            this.configApis = configApis;
            this.initHosts = initHosts;
            /**
             * @description 缓存的 host 表，以 bucket 和 assessKey 作为 key
             */
            this.cachedHostsMap = new Map();
        }
        /**
         * @description 注册可用 host
         */
        register(assessKey, bucketName, hosts) {
            this.cachedHostsMap.set(`${assessKey}@${bucketName}`, hosts.map(host => new Host(host, this.protocol)));
        }
        /**
         * @description 刷新最新的 host 数据，如果用户在构造时该类时传入了 host 或者已经存在缓存则不会发起请求
         */
        refresh(assessKey, bucketName) {
            return __awaiter(this, void 0, void 0, function* () {
                const cachedHostList = this.cachedHostsMap.get(`${assessKey}@${bucketName}`) || [];
                if (cachedHostList.length > 0)
                    return { result: false };
                if (this.initHosts && this.initHosts.length > 0) {
                    this.register(assessKey, bucketName, this.initHosts);
                    return { result: true };
                }
                const configResult = yield this.configApis.getHostConfig({
                    assessKey,
                    bucket: bucketName
                });
                if (!isSuccessResult(configResult)) {
                    return configResult;
                }
                const hostConfigs = configResult.result.hosts;
                if (hostConfigs && hostConfigs.length > 0) {
                    // 取第一个区域也就是当前空间所在区域的上传地址
                    // 暂时不用其他区域上传地址是是因为不同区域必须从头上传（第一个分片）
                    const hostConfig = hostConfigs[0];
                    this.register(assessKey, bucketName, [
                        // 严格依照优先级
                        ...hostConfig.up.domains,
                        ...hostConfig.up.old
                    ]);
                }
                return { result: true };
            });
        }
        /**
         * @description 获取一个可用的上传 Host，排除已冻结的
         */
        getUploadHost(params) {
            return __awaiter(this, void 0, void 0, function* () {
                const { assessKey, bucket } = params;
                const refreshResult = yield this.refresh(assessKey, bucket);
                if (!isSuccessResult(refreshResult))
                    return refreshResult;
                const cachedHostList = this.cachedHostsMap.get(`${assessKey}@${bucket}`) || [];
                if (cachedHostList.length === 0) {
                    return { error: new UploadError('InvalidUploadHost', 'No upload host available') };
                }
                const availableHostList = cachedHostList.filter(host => !host.isFrozen());
                if (availableHostList.length > 0)
                    return { result: availableHostList[0] };
                // 无可用的，去取离解冻最近的 host
                const priorityQueue = cachedHostList
                    .slice()
                    .sort((hostA, hostB) => (hostA.getUnfreezeTime() || 0) - (hostB.getUnfreezeTime() || 0));
                return { result: priorityQueue[0] };
            });
        }
    }
    class HostProvideTask {
        constructor(context, configApis, protocol, initHosts) {
            this.context = context;
            this.hostProvider = new HostProvider(protocol, configApis, initHosts);
            this.context.progress.details.prepareUploadHost = {
                fromCache: false,
                percent: 0,
                size: 0
            };
        }
        cancel() {
            return __awaiter(this, void 0, void 0, function* () {
                return { result: true };
            });
        }
        process(notice) {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function* () {
                const progress = new MockProgress(1);
                progress.onProgress(value => {
                    this.context.progress.details.prepareUploadHost.percent = value;
                    notice();
                });
                const needFreezeError = ['HttpRequestError', 'NetworkError'];
                if (this.context.error && needFreezeError.includes(this.context.error.name)) {
                    // 只要是网络错误就冻结当前的 host
                    (_a = this.context.host) === null || _a === void 0 ? void 0 : _a.freeze();
                }
                // 当前的 host 没有被冻结，继续复用
                if (((_b = this.context.host) === null || _b === void 0 ? void 0 : _b.isFrozen()) === false) {
                    this.context.progress.details.prepareUploadHost.fromCache = true;
                    progress.end();
                    return { result: true };
                }
                // 重新更新 host
                const token = this.context.token;
                const hostResult = yield this.hostProvider.getUploadHost(token);
                if (!isSuccessResult(hostResult)) {
                    if (isErrorResult(hostResult)) {
                        this.context.error = hostResult.error;
                    }
                    progress.stop();
                    return hostResult;
                }
                this.context.host = hostResult.result;
                progress.end();
                return { result: true };
            });
        }
    }

    function parsePutPolicy(token) {
        if (!token)
            return { error: new UploadError('InvalidToken', 'invalid token.') };
        const segments = token.split(':');
        if (segments.length === 1)
            return { error: new UploadError('InvalidToken', 'invalid token segments.') };
        // token 构造的差异参考：https://github.com/qbox/product/blob/master/kodo/auths/UpToken.md#admin-uptoken-authorization
        const assessKey = segments.length > 3 ? segments[1] : segments[0];
        if (!assessKey)
            return { error: new UploadError('InvalidToken', 'missing assess key field.') };
        let putPolicy = null;
        try {
            putPolicy = JSON.parse(urlSafeBase64Decode(segments[segments.length - 1]));
        }
        catch (error) {
            return { error: new UploadError('InvalidToken', 'token parse failed.') };
        }
        if (putPolicy == null) {
            return { error: new UploadError('InvalidToken', 'putPolicy is null.') };
        }
        if (putPolicy.scope == null) {
            return { error: new UploadError('InvalidToken', 'scope field is null.') };
        }
        if (putPolicy.deadline == null) {
            return { error: new UploadError('InvalidToken', 'deadline field is null.') };
        }
        const bucket = putPolicy.scope.split(':')[0];
        if (!bucket) {
            return { error: new UploadError('InvalidToken', 'resolve bucketName failed.') };
        }
        return {
            result: {
                bucket,
                assessKey,
                signature: token,
                deadline: putPolicy.deadline
            }
        };
    }

    class TokenProvideTask {
        constructor(context, userTokenProvider) {
            this.context = context;
            this.userTokenProvider = userTokenProvider;
            this.abort = new HttpAbortController();
            this.context.progress.details.prepareUploadToken = {
                fromCache: false,
                percent: 0,
                size: 0
            };
        }
        isExpired() {
            if (this.cachedToken == null)
                return true;
            // 如果剩余可用时间不足 2 分钟，则视为过期
            return this.cachedToken.deadline <= (Date.now() / 1e3) - 120;
        }
        /** 获取上传 token；自动根据 token 的过期时间更新 token */
        getUploadToken() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.cachedToken != null && !this.isExpired()) {
                    this.context.progress.details.prepareUploadToken.fromCache = true;
                    return { result: this.cachedToken };
                }
                const tokenResult = yield this.userTokenProvider()
                    .then(token => ({ result: token }))
                    .catch(() => ({ error: new UploadError('InvalidToken', 'Failed to get token') }));
                // 解析 token 并保存
                if (isSuccessResult(tokenResult)) {
                    const parseToken = parsePutPolicy(tokenResult.result);
                    if (!isSuccessResult(parseToken))
                        return parseToken;
                    this.cachedToken = parseToken.result;
                }
                return { result: this.cachedToken };
            });
        }
        cancel() {
            return __awaiter(this, void 0, void 0, function* () {
                this.abort.abort();
                return { result: true };
            });
        }
        process(notice) {
            return __awaiter(this, void 0, void 0, function* () {
                const progress = new MockProgress(1);
                progress.onProgress(value => {
                    this.context.progress.details.prepareUploadToken.percent = value;
                    notice();
                });
                progress.start();
                const uploadToken = yield this.getUploadToken();
                if (!isSuccessResult(uploadToken)) {
                    if (isErrorResult(uploadToken)) {
                        this.context.error = uploadToken.error;
                    }
                    progress.stop();
                    return uploadToken;
                }
                this.context.token = uploadToken.result;
                progress.end();
                return { result: true };
            });
        }
    }

    class DirectUploadContext extends UploadContext {
    }
    class DirectUploadTask {
        constructor(context, uploadApis, vars, file) {
            this.context = context;
            this.uploadApis = uploadApis;
            this.vars = vars;
            this.file = file;
            this.abort = null;
            this.context.progress.details.directUpload = {
                fromCache: false,
                percent: 0,
                size: 0
            };
        }
        cancel() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                yield ((_a = this.abort) === null || _a === void 0 ? void 0 : _a.abort());
                return { result: true };
            });
        }
        process(notify) {
            return __awaiter(this, void 0, void 0, function* () {
                const filenameResult = yield this.file.name();
                if (!isSuccessResult(filenameResult)) {
                    if (isErrorResult(filenameResult)) {
                        this.context.error = filenameResult.error;
                    }
                    return filenameResult;
                }
                const fileKeyResult = yield this.file.key();
                if (!isSuccessResult(fileKeyResult)) {
                    if (isErrorResult(fileKeyResult)) {
                        this.context.error = fileKeyResult.error;
                    }
                    return fileKeyResult;
                }
                const fileMetaResult = yield this.file.metadata();
                if (!isSuccessResult(fileMetaResult)) {
                    if (isErrorResult(fileMetaResult)) {
                        this.context.error = fileMetaResult.error;
                    }
                    return fileMetaResult;
                }
                const fileSizeResult = yield this.file.size();
                if (!isSuccessResult(fileSizeResult)) {
                    if (isErrorResult(fileSizeResult)) {
                        this.context.error = fileSizeResult.error;
                    }
                    return fileSizeResult;
                }
                this.abort = new HttpAbortController();
                const result = yield this.uploadApis.directUpload({
                    file: this.file,
                    abort: this.abort,
                    customVars: this.vars,
                    token: this.context.token,
                    metadata: fileMetaResult.result,
                    uploadHostUrl: this.context.host.getUrl(),
                    fileName: filenameResult.result || generateRandomString(),
                    key: fileKeyResult.result || filenameResult.result || undefined,
                    onProgress: progress => {
                        this.context.progress.details.directUpload.percent = progress.percent;
                        this.context.progress.details.directUpload.size = fileSizeResult.result;
                        notify();
                    }
                });
                if (isErrorResult(result)) {
                    this.context.error = result.error;
                }
                if (isSuccessResult(result)) {
                    this.context.result = result.result;
                }
                return result;
            });
        }
    }
    const createDirectUploadTask$1 = (file, config) => {
        const normalizedConfig = initUploadConfig(config);
        const uploadApis = new UploadApis(normalizedConfig.httpClient);
        const configApis = new ConfigApis(normalizedConfig.apiServerUrl, normalizedConfig.httpClient);
        const context = new DirectUploadContext();
        const directUploadTask = new DirectUploadTask(context, uploadApis, config.vars, file);
        const tokenProvideTask = new TokenProvideTask(context, normalizedConfig.tokenProvider);
        const hostProvideTask = new HostProvideTask(context, configApis, normalizedConfig.protocol, normalizedConfig.uploadHosts);
        const taskQueue = new TaskQueue({
            logger: { level: normalizedConfig.logLevel, prefix: 'directUploadQueue' },
            concurrentLimit: 1
        });
        taskQueue.enqueue(tokenProvideTask, hostProvideTask, directUploadTask);
        return {
            onError: fn => taskQueue.onError(() => {
                updateTotalIntoProgress(context.progress);
                fn(context.error, context);
            }),
            onComplete: fn => taskQueue.onComplete(() => {
                updateTotalIntoProgress(context.progress);
                fn(context.result, context);
            }),
            onProgress: fn => taskQueue.onProgress(() => {
                updateTotalIntoProgress(context.progress);
                fn(context.progress, context);
            }),
            start: () => {
                context.setup();
                updateTotalIntoProgress(context.progress);
                return taskQueue.start().then(() => ({ result: context.result }));
            },
            cancel: () => taskQueue.cancel()
        };
    };

    class MultipartUploadV1Context extends UploadContext {
        constructor() {
            super(...arguments);
            this.uploadBlocks = [];
        }
        setup() {
            super.setup();
        }
    }
    function isExpiredData(data) {
        if (!data || !data.expired_at)
            return true;
        // 如果剩余可用时间不足 2 分钟，则视为过期
        return data.expired_at <= ((Date.now() / 1e3) - 120);
    }
    class MkblkTask {
        constructor(context, uploadApis, blob, index) {
            this.context = context;
            this.uploadApis = uploadApis;
            this.blob = blob;
            this.index = index;
            this.abort = null;
            this.updateProgress(false, 0);
        }
        cancel() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                yield ((_a = this.abort) === null || _a === void 0 ? void 0 : _a.abort());
                return { result: true };
            });
        }
        updateProgress(fromCache, percent, notify) {
            const key = `multipartUpload:${this.index}`;
            if (this.context.progress.details[key] == null) {
                this.context.progress.details[key] = {
                    percent: 0,
                    fromCache: false,
                    size: this.blob.size()
                };
            }
            this.context.progress.details[key].fromCache = fromCache;
            this.context.progress.details[key].percent = percent;
            notify === null || notify === void 0 ? void 0 : notify();
        }
        process(notify) {
            return __awaiter(this, void 0, void 0, function* () {
                // 检查是否可以复用
                if (this.context.uploadBlocks.length > 0) {
                    const uploadedInfo = this.context.uploadBlocks[this.index];
                    if (uploadedInfo && !isExpiredData(uploadedInfo)) {
                        this.updateProgress(true, 1, notify);
                        return { result: true };
                    }
                }
                this.abort = new HttpAbortController();
                this.updateProgress(false, 0, notify);
                const uploadedPartResult = yield this.uploadApis.mkblk({
                    abort: this.abort,
                    token: this.context.token,
                    firstChunkBinary: this.blob,
                    uploadHostUrl: this.context.host.getUrl(),
                    onProgress: progress => { this.updateProgress(false, progress.percent, notify); }
                });
                if (isCanceledResult(uploadedPartResult)) {
                    return uploadedPartResult;
                }
                if (isErrorResult(uploadedPartResult)) {
                    // 发生错误仅仅更新到 context
                    this.context.error = uploadedPartResult.error;
                    return uploadedPartResult;
                }
                // 更新已上传分片信息到 context
                this.context.uploadBlocks[this.index] = uploadedPartResult.result;
                return uploadedPartResult;
            });
        }
    }
    class MkfileTask {
        constructor(context, uploadApis, vars, file) {
            this.context = context;
            this.uploadApis = uploadApis;
            this.vars = vars;
            this.file = file;
            this.abort = null;
            this.updateProgress(0);
        }
        cancel() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                yield ((_a = this.abort) === null || _a === void 0 ? void 0 : _a.abort());
                return { result: true };
            });
        }
        updateProgress(percent, notify) {
            if (this.context.progress.details.completeMultipartUpload == null) {
                this.context.progress.details.completeMultipartUpload = {
                    size: 0,
                    percent: 0,
                    fromCache: false
                };
            }
            this.context.progress.details.completeMultipartUpload.size = 0;
            this.context.progress.details.completeMultipartUpload.percent = percent;
            this.context.progress.details.completeMultipartUpload.fromCache = false;
            notify === null || notify === void 0 ? void 0 : notify();
        }
        process(notify) {
            return __awaiter(this, void 0, void 0, function* () {
                this.updateProgress(0, notify);
                const fileKeyResult = yield this.file.key();
                if (!isSuccessResult(fileKeyResult))
                    return fileKeyResult;
                const filenameResult = yield this.file.name();
                if (!isSuccessResult(filenameResult))
                    return filenameResult;
                const fileSizeResult = yield this.file.size();
                if (!isSuccessResult(fileSizeResult))
                    return fileSizeResult;
                const mimeTypeResult = yield this.file.mimeType();
                if (!isSuccessResult(mimeTypeResult))
                    return mimeTypeResult;
                const metadataResult = yield this.file.metadata();
                if (!isSuccessResult(metadataResult))
                    return metadataResult;
                this.abort = new HttpAbortController();
                const completeResult = yield this.uploadApis.mkfile({
                    abort: this.abort,
                    userVars: this.vars,
                    token: this.context.token,
                    fileSize: fileSizeResult.result,
                    uploadHostUrl: this.context.host.getUrl(),
                    fname: filenameResult.result || generateRandomString(),
                    lastCtxOfBlock: this.context.uploadBlocks.map(i => i.ctx),
                    key: fileKeyResult.result || filenameResult.result || undefined,
                    onProgress: progress => { this.updateProgress(progress.percent, notify); }
                });
                if (isSuccessResult(completeResult)) {
                    this.context.result = completeResult.result;
                }
                if (isErrorResult(completeResult)) {
                    this.context.error = completeResult.error;
                }
                return completeResult;
            });
        }
    }
    // eslint-disable-next-line max-len
    const createMultipartUploadV1Task$1 = (file, config) => {
        const normalizedConfig = initUploadConfig(config);
        const uploadApis = new UploadApis(normalizedConfig.httpClient);
        const configApis = new ConfigApis(normalizedConfig.apiServerUrl, normalizedConfig.httpClient);
        const context = new MultipartUploadV1Context();
        const tokenProvideTask = new TokenProvideTask(context, normalizedConfig.tokenProvider);
        const hostProvideTask = new HostProvideTask(context, configApis, normalizedConfig.protocol, normalizedConfig.uploadHosts);
        const mainQueue = new TaskQueue({
            logger: {
                level: normalizedConfig.logLevel,
                prefix: 'MultipartUploadQueue'
            },
            concurrentLimit: 1
        });
        // 分片任务单独使用一个子队列动态创建&执行
        const putQueue = new TaskQueue({
            logger: {
                level: normalizedConfig.logLevel,
                prefix: 'MultipartUploadChildQueue'
            },
            concurrentLimit: 1,
            // FIXME 动态创建任务会导致任务进度倒退
            tasksCreator: () => __awaiter(void 0, void 0, void 0, function* () {
                const sliceResult = yield file.slice(4 * 1024 * 1024);
                if (isErrorResult(sliceResult)) {
                    context.error = sliceResult.error;
                }
                if (!isSuccessResult(sliceResult)) {
                    return sliceResult;
                }
                const tasks = sliceResult.result.map((blob, index) => (new MkblkTask(context, uploadApis, blob, index)));
                return { result: tasks };
            })
        });
        const mkfileTask = new MkfileTask(context, uploadApis, normalizedConfig.vars, file);
        mainQueue.enqueue(tokenProvideTask, hostProvideTask, putQueue, mkfileTask);
        return {
            onError: fn => mainQueue.onError(() => {
                updateTotalIntoProgress(context.progress);
                fn(context.error, context);
            }),
            onComplete: fn => mainQueue.onComplete(() => {
                updateTotalIntoProgress(context.progress);
                fn(context.result, context);
            }),
            onProgress: fn => mainQueue.onProgress(() => {
                updateTotalIntoProgress(context.progress);
                fn(context.progress, context);
            }),
            start: () => {
                context.setup();
                updateTotalIntoProgress(context.progress);
                return mainQueue.start().then(() => ({ result: context.result }));
            },
            cancel: () => mainQueue.cancel()
        };
    };

    class MultipartUploadV2Context extends UploadContext {
        constructor() {
            super(...arguments);
            this.uploadedParts = [];
        }
        setup() {
            super.setup();
        }
    }
    class InitPartUploadTask {
        constructor(context, uploadApis, file) {
            this.context = context;
            this.uploadApis = uploadApis;
            this.file = file;
            this.abort = null;
            this.updateProgress(0);
        }
        cancel() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                yield ((_a = this.abort) === null || _a === void 0 ? void 0 : _a.abort());
                return { result: true };
            });
        }
        updateProgress(percent, notify) {
            if (this.context.progress.details.initMultipartUpload == null) {
                this.context.progress.details.initMultipartUpload = {
                    size: 0,
                    percent: 0,
                    fromCache: false
                };
            }
            this.context.progress.details.initMultipartUpload.size = 0;
            this.context.progress.details.initMultipartUpload.percent = percent;
            this.context.progress.details.initMultipartUpload.fromCache = false;
            notify === null || notify === void 0 ? void 0 : notify();
        }
        process(notify) {
            return __awaiter(this, void 0, void 0, function* () {
                this.abort = new HttpAbortController();
                this.updateProgress(0, notify);
                const filenameResult = yield this.file.name();
                if (!isSuccessResult(filenameResult))
                    return filenameResult;
                const fileKeyResult = yield this.file.key();
                if (!isSuccessResult(fileKeyResult))
                    return fileKeyResult;
                // 首先检查 context 上的 upload id 有没有过期
                if (this.context.uploadPartId) {
                    const nowTime = Date.now() / 1e3;
                    // 上次的 uploadPartId 还没过期 (至少剩余 60s)，继续使用
                    if ((this.context.uploadPartId.expireAt - 60) > nowTime) {
                        // 从服务端获取已上传的分片信息
                        const uploadedPartResult = yield this.uploadApis.listParts({
                            abort: this.abort,
                            token: this.context.token,
                            bucket: this.context.token.bucket,
                            uploadHostUrl: this.context.host.getUrl(),
                            uploadId: this.context.uploadPartId.uploadId,
                            key: fileKeyResult.result || filenameResult.result || undefined,
                            onProgress: progress => { this.updateProgress(progress.percent, notify); }
                        });
                        if (isCanceledResult(uploadedPartResult)) {
                            return uploadedPartResult;
                        }
                        if (isErrorResult(uploadedPartResult)) {
                            // 发生错误仅仅更新到 context，不 return
                            this.context.error = uploadedPartResult.error;
                        }
                        // 更新已上传分片信息到 context
                        if (isSuccessResult(uploadedPartResult) && uploadedPartResult.result.parts) {
                            this.context.uploadedParts.splice(0, Infinity);
                            this.context.uploadedParts.push(...uploadedPartResult.result.parts);
                            this.context.progress.details.initMultipartUpload.fromCache = true;
                            return uploadedPartResult;
                        }
                        // 错误情况直接走下面的 initMultipartUpload 流程重新初始化
                    }
                }
                const initResult = yield this.uploadApis.initMultipartUpload({
                    abort: this.abort,
                    token: this.context.token,
                    bucket: this.context.token.bucket,
                    uploadHostUrl: this.context.host.getUrl(),
                    key: fileKeyResult.result || filenameResult.result || undefined,
                    onProgress: progress => { this.updateProgress(progress.percent, notify); }
                });
                if (isSuccessResult(initResult)) {
                    this.context.uploadPartId = initResult.result;
                    this.context.uploadedParts.splice(0, Infinity);
                }
                if (isErrorResult(initResult)) {
                    this.context.error = initResult.error;
                }
                return initResult;
            });
        }
    }
    class UploadPartTask {
        constructor(context, uploadApis, index, file, blob) {
            this.context = context;
            this.uploadApis = uploadApis;
            this.index = index;
            this.file = file;
            this.blob = blob;
            this.abort = null;
            this.updateProgress(false, blob.size(), 0);
        }
        cancel() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                yield ((_a = this.abort) === null || _a === void 0 ? void 0 : _a.abort());
                return { result: true };
            });
        }
        updateProgress(fromCache, size, percent, notify) {
            const key = `multipartUpload:${this.index}`;
            if (this.context.progress.details[key] == null) {
                this.context.progress.details[key] = {
                    size: 0,
                    percent: 0,
                    fromCache: false
                };
            }
            this.context.progress.details[key].fromCache = fromCache;
            this.context.progress.details[key].percent = percent;
            this.context.progress.details[key].size = size;
            notify === null || notify === void 0 ? void 0 : notify();
        }
        process(notify) {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.context.uploadedParts.length > 0) {
                    const uploadedParts = this.context.uploadedParts;
                    const uploadedPart = uploadedParts.find(i => i.partNumber === this.index);
                    // 如果 number 和 size 匹配则直接跳过上传，复用分片
                    if (uploadedPart && 'size' in uploadedPart && uploadedPart.size === this.blob.size()) {
                        this.updateProgress(true, uploadedPart.size, 1, notify);
                        return { result: true };
                    }
                }
                const filenameResult = yield this.file.name();
                if (!isSuccessResult(filenameResult))
                    return filenameResult;
                const fileKeyResult = yield this.file.key();
                if (!isSuccessResult(fileKeyResult))
                    return fileKeyResult;
                const fileSizeResult = yield this.file.size();
                if (!isSuccessResult(fileSizeResult))
                    return fileSizeResult;
                this.abort = new HttpAbortController();
                const uploadPartResult = yield this.uploadApis.uploadPart({
                    part: this.blob,
                    abort: this.abort,
                    partIndex: this.index,
                    token: this.context.token,
                    bucket: this.context.token.bucket,
                    uploadHostUrl: this.context.host.getUrl(),
                    uploadId: this.context.uploadPartId.uploadId,
                    key: fileKeyResult.result || filenameResult.result || undefined,
                    onProgress: progress => { this.updateProgress(false, fileSizeResult.result, progress.percent, notify); }
                });
                if (isSuccessResult(uploadPartResult)) {
                    if (this.context.uploadedParts == null) {
                        this.context.uploadedParts = [];
                    }
                    this.context.uploadedParts.push({
                        partNumber: this.index,
                        etag: uploadPartResult.result.etag
                    });
                }
                if (isErrorResult(uploadPartResult)) {
                    this.context.error = uploadPartResult.error;
                }
                return uploadPartResult;
            });
        }
    }
    class CompletePartUploadTask {
        constructor(context, uploadApis, vars, file) {
            this.context = context;
            this.uploadApis = uploadApis;
            this.vars = vars;
            this.file = file;
            this.abort = null;
            this.updateProgress(0);
        }
        cancel() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                yield ((_a = this.abort) === null || _a === void 0 ? void 0 : _a.abort());
                return { result: true };
            });
        }
        updateProgress(percent, notify) {
            if (this.context.progress.details.completeMultipartUpload == null) {
                this.context.progress.details.completeMultipartUpload = {
                    size: 0,
                    percent: 0,
                    fromCache: false
                };
            }
            this.context.progress.details.completeMultipartUpload.size = 0;
            this.context.progress.details.completeMultipartUpload.percent = percent;
            this.context.progress.details.completeMultipartUpload.fromCache = false;
            notify === null || notify === void 0 ? void 0 : notify();
        }
        process(notify) {
            return __awaiter(this, void 0, void 0, function* () {
                this.updateProgress(0, notify);
                const fileKeyResult = yield this.file.key();
                if (!isSuccessResult(fileKeyResult))
                    return fileKeyResult;
                const filenameResult = yield this.file.name();
                if (!isSuccessResult(filenameResult))
                    return filenameResult;
                const mimeTypeResult = yield this.file.mimeType();
                if (!isSuccessResult(mimeTypeResult))
                    return mimeTypeResult;
                const metadataResult = yield this.file.metadata();
                if (!isSuccessResult(metadataResult))
                    return metadataResult;
                const sortedParts = this.context.uploadedParts
                    .map(item => ({ partNumber: item.partNumber, etag: item.etag }))
                    .sort((a, b) => a.partNumber - b.partNumber);
                this.abort = new HttpAbortController();
                const completeResult = yield this.uploadApis.completeMultipartUpload({
                    abort: this.abort,
                    parts: sortedParts,
                    customVars: this.vars,
                    token: this.context.token,
                    metadata: metadataResult.result,
                    uploadHostUrl: this.context.host.getUrl(),
                    mimeType: mimeTypeResult.result || undefined,
                    uploadId: this.context.uploadPartId.uploadId,
                    key: fileKeyResult.result || filenameResult.result || undefined,
                    fileName: filenameResult.result || generateRandomString(),
                    onProgress: progress => { this.updateProgress(progress.percent, notify); }
                });
                if (isSuccessResult(completeResult)) {
                    this.context.result = completeResult.result;
                }
                if (isErrorResult(completeResult)) {
                    this.context.error = completeResult.error;
                }
                return completeResult;
            });
        }
    }
    // eslint-disable-next-line max-len
    const createMultipartUploadV2Task$1 = (file, config) => {
        const normalizedConfig = initUploadConfig(config);
        const uploadApis = new UploadApis(normalizedConfig.httpClient);
        const configApis = new ConfigApis(normalizedConfig.apiServerUrl, normalizedConfig.httpClient);
        const context = new MultipartUploadV2Context();
        const tokenProvideTask = new TokenProvideTask(context, normalizedConfig.tokenProvider);
        const hostProvideTask = new HostProvideTask(context, configApis, normalizedConfig.protocol, normalizedConfig.uploadHosts);
        const initPartUploadTask = new InitPartUploadTask(context, uploadApis, file);
        const completePartUploadTask = new CompletePartUploadTask(context, uploadApis, config.vars, file);
        const mainQueue = new TaskQueue({
            logger: {
                level: normalizedConfig.logLevel,
                prefix: 'MultipartUploadQueue'
            },
            concurrentLimit: 1
        });
        // 分片任务单独使用一个子队列动态创建&执行
        const partQueue = new TaskQueue({
            logger: {
                level: normalizedConfig.logLevel,
                prefix: 'MultipartUploadChildQueue'
            },
            concurrentLimit: 3,
            // FIXME: 动态创建任务会导致任务进度倒退
            tasksCreator: () => __awaiter(void 0, void 0, void 0, function* () {
                const sliceResult = yield file.slice(4 * 1024 * 1024);
                if (isErrorResult(sliceResult)) {
                    context.error = sliceResult.error;
                }
                if (!isSuccessResult(sliceResult)) {
                    return sliceResult;
                }
                const tasks = sliceResult.result.map((blob, index) => (new UploadPartTask(context, uploadApis, index + 1, file, blob)));
                return { result: tasks };
            })
        });
        mainQueue.enqueue(tokenProvideTask, hostProvideTask, initPartUploadTask, partQueue, completePartUploadTask);
        return {
            onError: fn => mainQueue.onError(() => {
                updateTotalIntoProgress(context.progress);
                fn(context.error, context);
            }),
            onComplete: fn => mainQueue.onComplete(() => {
                updateTotalIntoProgress(context.progress);
                fn(context.result, context);
            }),
            onProgress: fn => mainQueue.onProgress(() => {
                updateTotalIntoProgress(context.progress);
                fn(context.progress, context);
            }),
            start: () => {
                context.setup();
                updateTotalIntoProgress(context.progress);
                return mainQueue.start().then(() => ({ result: context.result }));
            },
            cancel: () => mainQueue.cancel()
        };
    };

    function sliceChunk(fileSize, chunkSize) {
        const result = [];
        let offset = 0;
        while (offset < fileSize) {
            const size = Math.min(chunkSize, fileSize - offset);
            result.push({ offset, size });
            offset += chunkSize;
        }
        return result;
    }

    class UploadBlob {
        constructor(blob) {
            this.blob = blob;
        }
        size() {
            return this.blob.size;
        }
        readAsBrowserBlob() {
            return this.blob;
        }
    }
    class UploadFile {
        constructor(fileData) {
            this.fileData = fileData;
            if (this.fileData.type === 'file') {
                this.file = this.fileData.data;
                return;
            }
            if (this.fileData.type === 'array-buffer' || this.fileData.type === 'string') {
                this.file = new File([this.fileData.data], this.fileData.filename || '', { type: this.fileData.mimeType });
                return;
            }
            throw new Error('Unknown file type');
        }
        free() {
            return __awaiter(this, void 0, void 0, function* () {
                return { result: true };
            });
        }
        path() {
            return __awaiter(this, void 0, void 0, function* () {
                return { result: 'browser platform files' };
            });
        }
        key() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                return { result: ((_a = this.fileData) === null || _a === void 0 ? void 0 : _a.key) || null };
            });
        }
        name() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                const realFilename = this.fileData.type === 'file' && this.fileData.data.name;
                return { result: ((_a = this.fileData) === null || _a === void 0 ? void 0 : _a.filename) || realFilename || null };
            });
        }
        size() {
            return __awaiter(this, void 0, void 0, function* () {
                return { result: this.file.size };
            });
        }
        mimeType() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                return { result: ((_a = this.fileData) === null || _a === void 0 ? void 0 : _a.mimeType) || null };
            });
        }
        metadata() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                return { result: ((_a = this.fileData) === null || _a === void 0 ? void 0 : _a.metadata) || {} };
            });
        }
        slice(chunkSize) {
            return __awaiter(this, void 0, void 0, function* () {
                const sizeResult = yield this.size();
                if (!isSuccessResult(sizeResult))
                    return sizeResult;
                const normalizedChunkSize = chunkSize || sizeResult.result;
                return {
                    result: sliceChunk(sizeResult.result, normalizedChunkSize)
                        .map(({ offset, size }) => (new UploadBlob(this.file.slice(offset, offset + size, this.fileData.mimeType))))
                };
            });
        }
        readAsBrowserFile() {
            return this.file;
        }
    }
    function isUploadFile(data) {
        return data instanceof UploadFile;
    }
    function isUploadBlob(data) {
        return data instanceof UploadBlob;
    }

    function removeSpecifiedKeyForHeader(header, keys) {
        const headerKeys = Object.keys(header);
        for (let index = 0; index < headerKeys.length; index++) {
            for (let keyIndex = 0; keyIndex < keys.length; keyIndex++) {
                const key = keys[keyIndex].toLowerCase();
                const headerKey = headerKeys[index].toLowerCase();
                if (key === headerKey)
                    delete header[headerKeys[index]];
            }
        }
    }
    function normalizeBody(body) {
        if (isHttpFormData(body)) {
            const formData = new FormData();
            const bodyEntries = body.entries();
            for (const [key, value, option] of bodyEntries) {
                if (isUploadFile(value)) {
                    formData.set(key, value.readAsBrowserFile(), option);
                }
                else if (isUploadBlob(value)) {
                    formData.set(key, value.readAsBrowserBlob(), option);
                }
                else if (typeof option === 'string') {
                    // 如果无脑传第三个参数无法通过浏览器检查
                    formData.set(key, value, option);
                }
                else {
                    formData.set(key, value);
                }
            }
            return formData;
        }
        if (isUploadFile(body)) {
            return body.readAsBrowserFile();
        }
        if (isUploadBlob(body)) {
            return body.readAsBrowserBlob();
        }
        return JSON.stringify(body);
    }
    class HttpClient {
        request(url, options) {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise(resolve => {
                    // 默认是用 Xhr
                    const xhr = new XMLHttpRequest();
                    xhr.open(options.method, url);
                    if (options.abort) {
                        options.abort.onAbort(() => xhr.abort());
                    }
                    let mockProgress;
                    if (options.onProgress) {
                        const onProgress = options.onProgress;
                        // 实际上没有 body 可能导致即使添加了 upload.Listener 也不会触发
                        if (xhr.upload && xhr.upload.addEventListener && options.body) {
                            xhr.upload.addEventListener('load', () => {
                                onProgress({ percent: 1 });
                            });
                            xhr.upload.addEventListener('progress', (evt) => {
                                if (evt.lengthComputable)
                                    onProgress({ percent: evt.loaded / evt.total });
                            });
                        }
                        else {
                            // 对于不支持 xhr.upload 的一种兼容办法
                            mockProgress = new MockProgress();
                            mockProgress.onProgress(v => onProgress({ percent: v }));
                        }
                    }
                    xhr.onreadystatechange = () => {
                        if (xhr.readyState !== 4) {
                            return;
                        }
                        if (xhr.status === 0) {
                            mockProgress === null || mockProgress === void 0 ? void 0 : mockProgress.stop();
                            // 发生 0 基本都是网络错误，常见的比如跨域、断网、host 解析失败、系统拦截等等
                            resolve({ error: new UploadError('NetworkError', 'Unknown network error') });
                            return;
                        }
                        mockProgress === null || mockProgress === void 0 ? void 0 : mockProgress.end();
                        resolve({
                            result: {
                                reqId: xhr.getResponseHeader('x-reqId') || undefined,
                                code: xhr.status,
                                data: xhr.responseText
                            }
                        });
                    };
                    const normalizedBody = normalizeBody(options.body);
                    if (isHttpFormData(options.body)) {
                        if (options.headers) {
                            // formData 需要删除该字段让浏览器自动填充
                            removeSpecifiedKeyForHeader(options.headers, ['content-type']);
                        }
                    }
                    if (options.headers) {
                        const headers = options.headers;
                        Object.keys(headers).forEach(k => {
                            xhr.setRequestHeader(k, headers[k]);
                        });
                    }
                    xhr.send(normalizedBody);
                    if (mockProgress) {
                        mockProgress.start();
                    }
                });
            });
        }
        get(url, options) {
            return this.request(url, Object.assign({ method: 'GET' }, options));
        }
        put(url, options) {
            return this.request(url, Object.assign({ method: 'PUT' }, options));
        }
        post(url, options) {
            return this.request(url, Object.assign({ method: 'POST' }, options));
        }
        delete(url, options) {
            return this.request(url, Object.assign({ method: 'DELETE' }, options));
        }
    }

    function afterCancel(task, hook) {
        const rawCancel = task.cancel;
        task.cancel = () => __awaiter(this, void 0, void 0, function* () {
            const cancelResult = yield rawCancel();
            if (!isSuccessResult(cancelResult)) {
                return cancelResult;
            }
            return hook();
        });
    }
    const createDirectUploadTask = (file, config) => {
        var _a;
        const innerFile = new UploadFile(file);
        config.httpClient = (_a = config.httpClient) !== null && _a !== void 0 ? _a : new HttpClient();
        const task = createDirectUploadTask$1(innerFile, config);
        task.onError(() => innerFile.free());
        task.onComplete(() => innerFile.free());
        afterCancel(task, () => innerFile.free());
        return task;
    };
    const createMultipartUploadV1Task = (file, config) => {
        var _a;
        const innerFile = new UploadFile(file);
        config.httpClient = (_a = config.httpClient) !== null && _a !== void 0 ? _a : new HttpClient();
        const task = createMultipartUploadV1Task$1(innerFile, config);
        task.onError(() => innerFile.free());
        task.onComplete(() => innerFile.free());
        afterCancel(task, () => innerFile.free());
        return task;
    };
    const createMultipartUploadV2Task = (file, config) => {
        var _a;
        const innerFile = new UploadFile(file);
        config.httpClient = (_a = config.httpClient) !== null && _a !== void 0 ? _a : new HttpClient();
        const task = createMultipartUploadV2Task$1(innerFile, config);
        task.onError(() => innerFile.free());
        task.onComplete(() => innerFile.free());
        afterCancel(task, () => innerFile.free());
        return task;
    };

    exports.createDirectUploadTask = createDirectUploadTask;
    exports.createMultipartUploadV1Task = createMultipartUploadV1Task;
    exports.createMultipartUploadV2Task = createMultipartUploadV2Task;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.js.map
